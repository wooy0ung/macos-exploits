#include <CoreFoundation/CoreFoundation.h>
#include <IOKit/IOKitLib.h>

#include "physic.h"


// Definitions from IOPCIDevice.h
enum {
	kIOPCIConfigSpace      = 0,
	kIOPCIIOSpace          = 1,
	kIOPCI32BitMemorySpace = 2,
	kIOPCI64BitMemorySpace = 3
};

// Definitions from IOPCIPrivate.h
enum {
	kIOPCIDiagnosticsMethodRead  = 0,
	kIOPCIDiagnosticsMethodWrite = 1,
	kIOPCIDiagnosticsMethodCount
};

struct IOPCIDiagnosticsParameters {
	uint32_t options;
	uint32_t spaceType;
	uint32_t bitWidth;
	uint32_t _resv;
	uint64_t value;
	union {
		uint64_t addr64;
		struct {
			unsigned int offset     :16;
			unsigned int function   :3;
			unsigned int device     :5;
			unsigned int bus        :8;
			unsigned int segment    :16;
			unsigned int reserved   :16;
		} pci;
	} address;
};


#define TARGET_SERVICE "IOHIDevice"
static const char *target_service = TARGET_SERVICE;

// A connection to an instance of IOPCIDiagnosticsClient through which we can access physical
static io_connect_t connection;

void physic_init() {
	// Get a handle to a service that allows setting arbitrary IORegistry properties.
	io_service_t service = IOServiceGetMatchingService(kIOMasterPortDefault,
			IOServiceMatching(target_service));
	if (service == IO_OBJECT_NULL) {
		printf("could not find any services matching %s", target_service);
	}
	kern_return_t kr = IORegistryEntrySetCFProperty(service,
			CFSTR("IOUserClientClass"),
			CFSTR("IOPCIDiagnosticsClient"));
	if (kr != KERN_SUCCESS) {
		printf("could not set property: %x", kr);
	}
	// Create a connection to the IOPCIDiagnosticsClient.
	kr = IOServiceOpen(service, mach_task_self(), 0, &connection);
	IOObjectRelease(service);
	if (kr != KERN_SUCCESS) {
		printf("could not open connection: %x", kr);
	}
}

uint64_t physic_read(uint64_t paddr, unsigned width) {
	struct IOPCIDiagnosticsParameters param;
	param.spaceType      = kIOPCI64BitMemorySpace;
	param.bitWidth       = width * 8;
	param.options        = 0;
	param.address.addr64 = paddr;
	param.value          = -1;
	size_t size = sizeof(param);
	kern_return_t kr = IOConnectCallMethod(connection, kIOPCIDiagnosticsMethodRead,
	                                       NULL,       0,
	                                       &param,     sizeof(param),
	                                       NULL,       NULL,
	                                       &param,     &size);
	if (kr != KERN_SUCCESS) {
		printf("could not read physical address %p: %x", (void *)paddr, kr);
	}
	return param.value;
}

void physic_write(uint64_t paddr, uint64_t value, unsigned width) {
	struct IOPCIDiagnosticsParameters param;
	param.spaceType      = kIOPCI64BitMemorySpace;
	param.bitWidth       = width * 8;
	param.options        = 0;
	param.address.addr64 = paddr;
	param.value          = value;
	kern_return_t kr = IOConnectCallMethod(connection, kIOPCIDiagnosticsMethodWrite,
	                                       NULL,       0,
	                                       &param,     sizeof(param),
	                                       NULL,       NULL,
	                                       NULL,       NULL);
	if (kr != KERN_SUCCESS) {
		printf("could not write physical address %p: %x", (void *)paddr, kr);
	}
}
